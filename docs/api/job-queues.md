# Job Queues & Task Scheduling with ScorpionJS

ScorpionJS provides robust support for background job processing and task scheduling, allowing you to offload long-running tasks, manage retries, and schedule periodic jobs efficiently.

## Overview

Integrate seamlessly with popular job queue systems or use ScorpionJS's built-in capabilities to manage asynchronous tasks.

## Features

- **Adapters for Popular Queues**: 
  - BullMQ / Bull
  - Agenda.js
  - RabbitMQ (via common libraries)
  - Kafka (for event-driven task processing)
- **Built-in Simple Queue**: For development or less demanding use cases, ScorpionJS offers a simple in-memory or database-backed queue.
- **Job Definition**: Easily define jobs that can call service methods or custom functions.
- **Task Scheduling**: Schedule jobs to run at specific times, recurring intervals (CRON expressions), or after a delay.
- **Retry Mechanisms**: Automatic retries for failed jobs with configurable backoff strategies.
- **Concurrency Control**: Manage the number of concurrent workers processing jobs.
- **Progress Tracking**: Monitor the progress of long-running jobs.
- **Prioritization**: Assign priorities to jobs to ensure critical tasks are processed first.
- **Distributed Workers**: Scale your job processing capabilities by running workers on multiple nodes.
- **Admin UI Integration**: Monitor and manage jobs through the [ScorpionJS Admin Dashboard](./guides/admin-ui.md).
- **Rich Data Payloads**: Jobs robustly support complex, structured data payloads, allowing rich information to be passed to and from background tasks.
- **Job Chaining & Data Pipelines**: Construct sophisticated workflows where the output data of one job seamlessly becomes the input for the next, enabling complex data processing sequences.
- **Conditional Job Dispatch**: Trigger jobs dynamically based on specific data conditions, events from services, or external system triggers, ensuring jobs run only when relevant data criteria are met.
- **Data-Aware Idempotency**: Ensure jobs are processed uniquely based on their data content or a derived signature, preventing redundant executions and ensuring data consistency.
- **Job Input/Output Schema Validation**: Define and enforce schemas for job input data and expected output, maintaining data integrity throughout asynchronous processes, similar to [Schema Validation API](./schema-validation.md) for services.
- **Persistent Job Results & Querying**: Systematically store the results, output data, and error information of completed jobs, with APIs to query and retrieve this historical data for auditing, analytics, or further processing.
- **User-Context Propagation**: Automatically carry forward or explicitly assign user context (ID, roles, permissions) to jobs, enabling secure, user-specific operations within background tasks.
- **User-Specific Job Prioritization/Routing**: Route or prioritize jobs based on user attributes (e.g., subscription level, user group), allowing for differentiated service quality and resource allocation.
- **Per-User Job Rate Limiting & Concurrency**: Enforce limits on job submission rates or concurrent job execution per user, ensuring fair usage and system stability.
- **User-Centric Job Visibility & Management**: Enable users to view the status and history of their own jobs, and where appropriate, manage them (e.g., cancel pending jobs), often integrated with user-facing dashboards or the [ScorpionJS Admin Dashboard](./guides/admin-ui.md).
- **User-Specific Notifications on Job Lifecycle Events**: Configure jobs to automatically notify the initiating or relevant user upon completion, failure, or other significant milestones in the job's lifecycle.
- **User-Specific Data Encryption for Job Payloads**: For jobs handling sensitive user information, support encryption of job data at rest and in transit using user-specific keys or contexts, ensuring data privacy.
- **Auditing User-Initiated and User-Data-Affecting Jobs**: Maintain detailed audit trails for all jobs initiated by users or that access/modify user-specific data, including who initiated the job, when, and what data was affected.
- **User Preference Driven Job Behavior**: Allow jobs to dynamically alter their execution logic based on stored user preferences (e.g., notification settings, data processing options, output formats).
- **User-Scoped Job Data Storage**: Ensure that any temporary data, artifacts, or logs generated by jobs processing user-specific tasks are stored in a manner that respects user data isolation and privacy policies.
- **Strict Impersonation Controls for Jobs**: Implement robust mechanisms and audit trails for jobs that need to perform actions on behalf of a user, ensuring that impersonation is time-bound, permission-limited, and explicitly authorized.

## Setup Example (with BullMQ adapter)

```javascript
import { createApp } from 'scorpionjs';
import jobQueue from 'scorpionjs-bullmq';

const app = createApp();

// Configure the job queue
app.configure(jobQueue({
  connection: {
    host: 'localhost',
    port: 6379
  }
}));

// Define a job processor (can be a service method)
app.service('email', {
  async sendWelcomeEmail(job) {
    const { userId } = job.data;
    // ... logic to send email ...
    console.log(`Welcome email sent to user ${userId}`);
    return { status: 'sent' };
  }
});

// Add a job to the queue
async function enqueueWelcomeEmail(userId) {
  await app.jobs.getQueue('default').add('sendWelcomeEmail', {
    service: 'email',
    method: 'sendWelcomeEmail',
    data: { userId }
  });
}

// Schedule a recurring task
app.jobs.getQueue('default').add('cleanupOldData', 
  { service: 'dataMaintenance', method: 'cleanup' }, 
  { repeat: { cron: '0 0 * * *' } } // Every day at midnight
);

app.listen(3000);
```
